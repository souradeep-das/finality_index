import {} from "../pool/createPool.js";
import { parseRequest } from "./parseRequest.js";
import httpProxy from "http-proxy";
import { IncomingMessage, ServerResponse, createServer } from "node:http";
/**
 * Creates a proxy server that spawns anvil instance on demand.
 *
 * @example
 * ```
 * import { createProxy, createPool } from "@viem/anvil";
 *
 * const server = createProxy({
 *   pool: createPool(),
 *   options: {
 *     forkUrl: "https://eth-mainnet.alchemyapi.io/v2/<API_KEY>",
 *     blockNumber: 12345678,
 *   },
 * });
 *
 * server.listen(8545, "::", () => {
 *   console.log("Proxy server listening on http://0.0.0.0:8545");
 * });
 * ```
 */
export async function createProxy({ pool, options, fallback, }) {
    let httpProxyWithCjsFallback = httpProxy;
    if (httpProxyWithCjsFallback === undefined) {
        httpProxyWithCjsFallback = await import("http-proxy").then(
        // rome-ignore lint/suspicious/noExplicitAny: required to support both esm & cjs.
        (module) => module.default);
    }
    const proxy = await httpProxyWithCjsFallback.createProxyServer({
        ignorePath: true,
        ws: true,
    });
    const server = createServer(async (req, res) => {
        try {
            const context = parseRequest(req.url);
            if (context !== undefined) {
                switch (context.path) {
                    case "/": {
                        const anvil = (await pool.get(context.id)) ??
                            (await pool.start(context.id, typeof options === "function"
                                ? await options(context.id, req)
                                : options));
                        return proxy.web(req, res, {
                            target: `http://${anvil.host}:${anvil.port}`,
                        });
                    }
                    case "/start": {
                        if (pool.has(context.id)) {
                            return sendFailure(res, {
                                code: 404,
                                reason: "Anvil instance already exists",
                            });
                        }
                        await pool.start(context.id, typeof options === "function"
                            ? await options(context.id, req)
                            : options);
                        return sendSuccess(res);
                    }
                    case "/stop": {
                        const success = await pool
                            .stop(context.id)
                            .then(() => true)
                            .catch(() => false);
                        return sendResponse(res, 200, { success });
                    }
                    case "/logs": {
                        const anvil = await pool.get(context.id);
                        if (anvil !== undefined) {
                            const logs = (await anvil.logs) ?? [];
                            return sendSuccess(res, { logs });
                        }
                        return sendFailure(res, {
                            code: 404,
                            reason: `Anvil instance doesn't exist`,
                        });
                    }
                }
            }
            if (fallback !== undefined) {
                return await fallback(req, res, { ...context, pool, options });
            }
            return sendFailure(res, {
                code: 404,
                reason: "Unsupported request",
            });
        }
        catch (error) {
            console.error(error);
            return sendFailure(res, {
                code: 500,
                reason: "Internal server error",
            });
        }
    });
    server.on("upgrade", async (req, socket, head) => {
        const context = parseRequest(req.url);
        if (context?.path === "/") {
            const anvil = (await pool.get(context.id)) ??
                (await pool.start(context.id, typeof options === "function"
                    ? await options(context.id, req)
                    : options));
            proxy.ws(req, socket, head, {
                target: `ws://${anvil.host}:${anvil.port}`,
            });
        }
        else {
            socket.destroy(new Error("Unsupported request"));
        }
    });
    return server;
}
function sendFailure(res, { reason = "Unsupported request", code = 400, } = {}) {
    sendResponse(res, code, {
        reason,
        success: false,
    });
}
function sendSuccess(res, output) {
    sendResponse(res, 200, {
        ...output,
        success: true,
    });
}
function sendResponse(res, code = 200, output) {
    const json = JSON.stringify({
        ...output,
        success: output?.success ?? code === 200,
    });
    res.writeHead(200).end(json);
}
//# sourceMappingURL=createProxy.js.map