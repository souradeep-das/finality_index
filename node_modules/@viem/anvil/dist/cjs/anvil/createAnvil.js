"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createAnvil = void 0;
const stripColors_js_1 = require("./stripColors.js");
const toArgs_js_1 = require("./toArgs.js");
const node_events_1 = require("node:events");
const node_stream_1 = require("node:stream");
/**
 * Creates anvil instance.
 */
function createAnvil(options = {}) {
    const emitter = new node_events_1.EventEmitter();
    const logs = [];
    emitter.on("message", (message) => {
        logs.push(message);
        if (logs.length > 20) {
            logs.shift();
        }
    });
    let anvil;
    let controller;
    let status = "idle";
    const { anvilBinary = "anvil", execArgs: execArgs_, startTimeout = 10_000, stopTimeout = 10_000, ...anvilOptions } = options;
    const stdout = new node_stream_1.Writable({
        write(chunk, _, callback) {
            try {
                const message = (0, stripColors_js_1.stripColors)(chunk.toString());
                emitter.emit("message", message);
                emitter.emit("stdout", message);
                callback();
            }
            catch (error) {
                callback(error instanceof Error
                    ? error
                    : new Error(typeof error === "string" ? error : undefined));
            }
        },
    });
    const stderr = new node_stream_1.Writable({
        write(chunk, _, callback) {
            try {
                const message = (0, stripColors_js_1.stripColors)(chunk.toString());
                emitter.emit("message", message);
                emitter.emit("stderr", message);
                callback();
            }
            catch (error) {
                callback(error instanceof Error
                    ? error
                    : new Error(typeof error === "string" ? error : undefined));
            }
        },
    });
    async function start() {
        if (status !== "idle") {
            throw new Error("Anvil instance not idle");
        }
        status = "starting";
        // rome-ignore lint/suspicious/noAsyncPromiseExecutor: this is fine ...
        return new Promise(async (resolve, reject) => {
            let log = undefined;
            async function setFailed(reason) {
                status = "stopping";
                clearTimeout(timeout);
                emitter.off("message", onMessage);
                emitter.off("exit", onExit);
                try {
                    if (controller !== undefined && !controller?.signal.aborted) {
                        controller.abort();
                    }
                    await anvil;
                }
                catch { }
                status = "idle";
                reject(reason);
            }
            function setStarted() {
                status = "listening";
                clearTimeout(timeout);
                emitter.off("message", onMessage);
                emitter.off("exit", onExit);
                resolve();
            }
            function onExit() {
                if (status === "starting") {
                    if (log !== undefined) {
                        setFailed(new Error(`Anvil exited: ${log}`));
                    }
                    else {
                        setFailed(new Error("Anvil exited"));
                    }
                }
            }
            function onMessage(message) {
                log = message;
                if (status === "starting") {
                    // We know that anvil is listening when it prints this message.
                    if (message.includes('Listening on')) {
                        setStarted();
                    }
                }
            }
            emitter.on("exit", onExit);
            emitter.on("message", onMessage);
            const timeout = setTimeout(() => {
                setFailed(new Error("Anvil failed to start in time"));
            }, startTimeout);
            controller = new AbortController();
            const execArgs = (() => {
                const args = [
                    anvilBinary,
                    (0, toArgs_js_1.toArgs)(anvilOptions),
                    { signal: controller.signal, cleanup: true },
                ];
                if (typeof execArgs_ === "undefined") {
                    return args;
                }
                if (typeof execArgs_ === "function") {
                    return execArgs_(args);
                }
                return execArgs_;
            })();
            const { execa } = await import("execa");
            anvil = execa(...execArgs);
            anvil.on("closed", () => emitter.emit("closed"));
            anvil.on("exit", (code, signal) => {
                emitter.emit("exit", code ?? undefined, signal ?? undefined);
            });
            // rome-ignore lint/style/noNonNullAssertion: this is guaranteed to be defined
            anvil.pipeStdout(stdout);
            // rome-ignore lint/style/noNonNullAssertion: this is guaranteed to be defined
            anvil.pipeStderr(stderr);
        });
    }
    async function stop() {
        if (status === "idle") {
            return;
        }
        const timeout = new Promise((_, reject) => {
            setTimeout(() => {
                reject(new Error("Anvil failed to stop in time"));
            }, stopTimeout);
        });
        const closed = new Promise((resolve) => {
            anvil?.once("close", () => resolve());
        });
        try {
            if (controller !== undefined && !controller?.signal.aborted) {
                controller.abort();
            }
            await anvil;
        }
        catch { }
        status = "idle";
        anvil = undefined;
        controller = undefined;
        return Promise.race([closed, timeout]);
    }
    return {
        start,
        stop,
        // rome-ignore lint/suspicious/noExplicitAny: typed via the return type
        on: (event, listener) => {
            emitter.on(event, listener);
            return () => {
                emitter.off(event, listener);
            };
        },
        get status() {
            return status;
        },
        get logs() {
            return logs.slice();
        },
        get port() {
            return options.port ?? 8545;
        },
        get host() {
            return options.host ?? "127.0.0.1";
        },
        get options() {
            // NOTE: This is effectively a safe, readonly copy because the options are a flat object.
            return { ...options };
        },
    };
}
exports.createAnvil = createAnvil;
//# sourceMappingURL=createAnvil.js.map